//! Wundt Optimizer: Intrinsic Motivation through Arousal-Valence Optimization
//!
//! "The system that seeks its own optimal experience"
//!
//! Based on Wilhelm Wundt's psychological law: optimal experience occurs at
//! intermediate arousal levels - not too boring (low arousal) and not too
//! overwhelming (high arousal). This creates intrinsic motivation for the
//! system to seek complexity that's "just right".

use crate::generative::{OscillatoryNetwork, SimParams};
use crate::perceptual::{TopologicalFeatures, TopologicalPerceiver};
use rand;
use std::collections::VecDeque;

/// Parameters for Wundt curve optimization
#[derive(Debug, Clone)]
pub struct WundtParams {
    /// Optimal arousal level (peak of inverted-U curve)
    pub optimal_arousal: f64,

    /// Width of the optimal zone (how tolerant to deviation)
    pub optimal_zone_width: f64,

    /// Learning rate for arousal adjustment
    pub learning_rate: f64,

    /// Exploration vs exploitation balance
    pub exploration_factor: f64,

    /// Time constant for arousal smoothing
    pub arousal_tau: f64,
}

impl Default for WundtParams {
    fn default() -> Self {
        Self {
            optimal_arousal: 0.6,    // 60% arousal is optimal
            optimal_zone_width: 0.2, // Â±20% tolerance
            learning_rate: 0.01,     // Slow adaptation
            exploration_factor: 0.3, // 30% exploration
            arousal_tau: 0.5,        // 500ms smoothing
        }
    }
}

/// The Wundt Optimizer that generates intrinsic motivation
///
/// This system monitors the network's arousal level (derived from topological
/// complexity and oscillatory dynamics) and generates motivational signals
/// to keep the system in its optimal experience zone.
pub struct WundtOptimizer {
    /// Wundt curve parameters
    params: WundtParams,

    /// History of arousal levels for trend analysis
    arousal_history: VecDeque<f64>,

    /// Current arousal estimate
    current_arousal: f64,

    /// Intrinsic motivation signal (0.0 to 1.0)
    motivation: f64,

    /// Exploration drive (0.0 to 1.0)
    exploration_drive: f64,

    /// Control signals for network parameters
    control_signals: ControlSignals,

    /// Maximum history size
    max_history: usize,
}

/// Control signals generated by the optimizer
#[derive(Debug, Clone)]
pub struct ControlSignals {
    /// Frequency adjustment signal (-1.0 to 1.0)
    pub frequency_adjustment: f64,

    /// Inhibition adjustment signal (-1.0 to 1.0)
    pub inhibition_adjustment: f64,

    /// Noise injection signal (0.0 to 1.0)
    pub noise_signal: f64,

    /// Parameter exploration magnitude (0.0 to 1.0)
    pub exploration_magnitude: f64,
}

/// Intrinsic motivation state
#[derive(Debug, Clone)]
pub struct IntrinsicMotivation {
    /// Current motivation level
    pub motivation: f64,

    /// Arousal deficit (how far from optimal)
    pub arousal_deficit: f64,

    /// Exploration vs exploitation bias
    pub exploration_bias: f64,

    /// Predicted optimal action
    pub optimal_action: MotivationalAction,
}

/// Possible motivational actions
#[derive(Debug, Clone, PartialEq)]
pub enum MotivationalAction {
    /// Increase complexity (seek more stimulation)
    IncreaseComplexity,

    /// Decrease complexity (seek less stimulation)
    DecreaseComplexity,

    /// Maintain current state (optimal zone)
    MaintainOptimal,

    /// Explore new patterns (seek novelty)
    ExploreNovelty,

    /// Exploit known patterns (seek mastery)
    ExploitKnown,
}

impl WundtOptimizer {
    /// Create a new Wundt optimizer with default parameters
    pub fn new() -> Self {
        Self {
            params: WundtParams::default(),
            arousal_history: VecDeque::new(),
            current_arousal: 0.5,
            motivation: 0.5,
            exploration_drive: 0.3,
            control_signals: ControlSignals::default(),
            max_history: 100,
        }
    }

    /// Create optimizer with custom parameters
    pub fn with_params(params: WundtParams) -> Self {
        Self {
            params,
            arousal_history: VecDeque::new(),
            current_arousal: 0.5,
            motivation: 0.5,
            exploration_drive: 0.3,
            control_signals: ControlSignals::default(),
            max_history: 100,
        }
    }

    /// Update optimizer state based on current system state
    pub fn update(
        &mut self,
        network: &OscillatoryNetwork,
        features: &TopologicalFeatures,
    ) -> IntrinsicMotivation {
        // 1. Compute current arousal from network and topological state
        let arousal = self.compute_arousal(network, features);
        self.update_arousal(arousal);

        // 2. Compute intrinsic motivation using Wundt curve
        let motivation = self.compute_motivation();
        self.motivation = motivation;

        // 3. Determine optimal action based on arousal deficit
        let optimal_action = self.determine_optimal_action();

        // 4. Generate control signals
        self.generate_control_signals();

        // 5. Update exploration drive
        self.update_exploration_drive();

        IntrinsicMotivation {
            motivation,
            arousal_deficit: (self.params.optimal_arousal - self.current_arousal).abs(),
            exploration_bias: self.exploration_drive,
            optimal_action,
        }
    }

    /// Compute arousal from network dynamics and topological complexity
    fn compute_arousal(&self, network: &OscillatoryNetwork, features: &TopologicalFeatures) -> f64 {
        // 1. Network dynamics contribution (oscillation frequency and amplitude)
        let frequency_arousal = self.frequency_to_arousal(network.params.frequency);
        let complexity_arousal = network.get_network_complexity();

        // 2. Topological contribution (persistence entropy and betti numbers)
        let topological_arousal = features.persistence_entropy;
        let betti_arousal = (features.betti_numbers.b0
            + features.betti_numbers.b1
            + features.betti_numbers.b2) as f64
            / 10.0; // Normalize

        // 3. Combine arousal components with weights
        let total_arousal = (frequency_arousal * 0.3
            + complexity_arousal * 0.3
            + topological_arousal * 0.2
            + betti_arousal * 0.2)
            .clamp(0.0, 1.0);

        total_arousal
    }

    /// Convert oscillation frequency to arousal level
    fn frequency_to_arousal(&self, frequency: f64) -> f64 {
        // Map frequency range (0.1-100 Hz) to arousal (0.0-1.0)
        // Optimal arousal around 10-20 Hz (alpha/beta range)
        if frequency < 1.0 {
            0.1 // Very low frequency = low arousal
        } else if frequency < 10.0 {
            0.3 + (frequency - 1.0) / 9.0 * 0.3 // Rising to optimal
        } else if frequency < 30.0 {
            0.6 + (frequency - 10.0) / 20.0 * 0.3 // Optimal zone
        } else if frequency < 60.0 {
            0.9 - (frequency - 30.0) / 30.0 * 0.2 // Declining from optimal
        } else {
            0.7 // Very high frequency = over-arousal
        }
    }

    /// Update arousal with exponential smoothing
    fn update_arousal(&mut self, new_arousal: f64) {
        // Exponential moving average
        let alpha = self.params.learning_rate;
        self.current_arousal = alpha * new_arousal + (1.0 - alpha) * self.current_arousal;

        // Store in history
        self.arousal_history.push_back(self.current_arousal);
        while self.arousal_history.len() > self.max_history {
            self.arousal_history.pop_front();
        }
    }

    /// Compute intrinsic motivation using Wundt's inverted-U curve
    fn compute_motivation(&self) -> f64 {
        let arousal_diff = (self.current_arousal - self.params.optimal_arousal).abs();

        if arousal_diff <= self.params.optimal_zone_width / 2.0 {
            // In optimal zone - high motivation to maintain
            0.9
        } else if arousal_diff <= self.params.optimal_zone_width {
            // Near optimal zone - moderate motivation
            0.7
        } else {
            // Far from optimal - motivation to return
            let distance_factor = 1.0 - (arousal_diff - self.params.optimal_zone_width).min(0.5);
            distance_factor * 0.5
        }
    }

    /// Determine optimal action based on current arousal
    fn determine_optimal_action(&self) -> MotivationalAction {
        let arousal_diff = self.current_arousal - self.params.optimal_arousal;

        if arousal_diff.abs() <= self.params.optimal_zone_width / 2.0 {
            // In optimal zone
            if self.exploration_drive > 0.5 {
                MotivationalAction::ExploreNovelty
            } else {
                MotivationalAction::MaintainOptimal
            }
        } else if arousal_diff > 0.0 {
            // Over-aroused - decrease complexity
            MotivationalAction::DecreaseComplexity
        } else {
            // Under-aroused - increase complexity
            MotivationalAction::IncreaseComplexity
        }
    }

    /// Generate control signals based on motivational state
    fn generate_control_signals(&mut self) {
        let arousal_diff = self.current_arousal - self.params.optimal_arousal;

        match self.determine_optimal_action() {
            MotivationalAction::IncreaseComplexity => {
                self.control_signals.frequency_adjustment = 0.3;
                self.control_signals.inhibition_adjustment = -0.2;
                self.control_signals.noise_signal = 0.4;
                self.control_signals.exploration_magnitude = 0.6;
            }
            MotivationalAction::DecreaseComplexity => {
                self.control_signals.frequency_adjustment = -0.2;
                self.control_signals.inhibition_adjustment = 0.3;
                self.control_signals.noise_signal = 0.1;
                self.control_signals.exploration_magnitude = 0.2;
            }
            MotivationalAction::MaintainOptimal => {
                self.control_signals.frequency_adjustment = 0.0;
                self.control_signals.inhibition_adjustment = 0.0;
                self.control_signals.noise_signal = 0.2;
                self.control_signals.exploration_magnitude = 0.3;
            }
            MotivationalAction::ExploreNovelty => {
                self.control_signals.frequency_adjustment = (rand::random::<f64>() - 0.5) * 0.4;
                self.control_signals.inhibition_adjustment = (rand::random::<f64>() - 0.5) * 0.4;
                self.control_signals.noise_signal = 0.6;
                self.control_signals.exploration_magnitude = 0.8;
            }
            MotivationalAction::ExploitKnown => {
                self.control_signals.frequency_adjustment = -0.1;
                self.control_signals.inhibition_adjustment = 0.1;
                self.control_signals.noise_signal = 0.1;
                self.control_signals.exploration_magnitude = 0.1;
            }
        }
    }

    /// Update exploration drive based on recent performance
    fn update_exploration_drive(&mut self) {
        if self.arousal_history.len() < 10 {
            return;
        }

        // Compute arousal variance (stability measure)
        let recent_arousal: Vec<f64> = self
            .arousal_history
            .iter()
            .rev()
            .take(10)
            .cloned()
            .collect();
        let mean_arousal = recent_arousal.iter().sum::<f64>() / recent_arousal.len() as f64;
        let variance = recent_arousal
            .iter()
            .map(|a| (a - mean_arousal).powi(2))
            .sum::<f64>()
            / recent_arousal.len() as f64;

        // High variance = unstable, increase exploration
        // Low variance = stable, decrease exploration
        let exploration_adjustment = if variance > 0.01 {
            0.1 // Increase exploration
        } else {
            -0.05 // Decrease exploration
        };

        self.exploration_drive = (self.exploration_drive + exploration_adjustment).clamp(0.1, 0.9);
    }

    /// Apply control signals to network parameters
    pub fn apply_control(&self, network: &mut OscillatoryNetwork) {
        let current_params = &network.params;

        // Apply frequency adjustment
        let new_frequency = (current_params.frequency
            + self.control_signals.frequency_adjustment * 5.0) // Scale adjustment
            .clamp(0.1, 100.0);

        // Apply inhibition adjustment
        let new_inhibition = (current_params.inhib_amplitude
            + self.control_signals.inhibition_adjustment * 2.0)
            .clamp(0.0, 10.0);

        // Create new parameters
        let new_params = SimParams::new(
            new_frequency,
            new_inhibition,
            current_params.tau_activation,
            current_params.tau_refractory,
        );

        network.update_params(new_params);

        // Apply noise if signal is high
        if self.control_signals.noise_signal > 0.3 {
            let noise_strength = self.control_signals.noise_signal * 0.1;
            network.apply_network_noise(noise_strength);
        }
    }

    /// Get current intrinsic motivation state
    pub fn get_motivation(&self) -> IntrinsicMotivation {
        IntrinsicMotivation {
            motivation: self.motivation,
            arousal_deficit: (self.params.optimal_arousal - self.current_arousal).abs(),
            exploration_bias: self.exploration_drive,
            optimal_action: self.determine_optimal_action(),
        }
    }

    /// Get control signals
    pub fn get_control_signals(&self) -> &ControlSignals {
        &self.control_signals
    }

    /// Get arousal history
    pub fn get_arousal_history(&self) -> Vec<f64> {
        self.arousal_history.iter().cloned().collect()
    }

    /// Reset optimizer state
    pub fn reset(&mut self) {
        self.arousal_history.clear();
        self.current_arousal = 0.5;
        self.motivation = 0.5;
        self.exploration_drive = 0.3;
        self.control_signals = ControlSignals::default();
    }

    /// Get optimizer statistics
    pub fn get_statistics(&self) -> WundtStats {
        WundtStats {
            optimal_arousal: self.params.optimal_arousal,
            current_arousal: self.current_arousal,
            motivation: self.motivation,
            exploration_drive: self.exploration_drive,
            arousal_deficit: (self.params.optimal_arousal - self.current_arousal).abs(),
            optimal_action: self.determine_optimal_action(),
            history_length: self.arousal_history.len(),
        }
    }
}

impl Default for ControlSignals {
    fn default() -> Self {
        Self {
            frequency_adjustment: 0.0,
            inhibition_adjustment: 0.0,
            noise_signal: 0.2,
            exploration_magnitude: 0.3,
        }
    }
}

/// Statistics about the Wundt optimizer state
#[derive(Debug, Clone)]
pub struct WundtStats {
    pub optimal_arousal: f64,
    pub current_arousal: f64,
    pub motivation: f64,
    pub exploration_drive: f64,
    pub arousal_deficit: f64,
    pub optimal_action: MotivationalAction,
    pub history_length: usize,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::generative::InputPattern;

    #[test]
    fn test_wundt_optimizer_creation() {
        let mut optimizer = WundtOptimizer::new();

        assert!(optimizer.params.optimal_arousal > 0.0);
        assert!(optimizer.params.optimal_arousal < 1.0);

        optimizer.current_arousal = 0.6; // Near optimal
        optimizer.motivation = 0.5;
        assert_eq!(optimizer.exploration_drive, 0.3);
    }

    #[test]
    fn test_wundt_optimizer_with_params() {
        let params = WundtParams {
            optimal_arousal: 0.7,
            optimal_zone_width: 0.3,
            learning_rate: 0.02,
            exploration_factor: 0.4,
            arousal_tau: 0.6,
        };

        let mut optimizer = WundtOptimizer::with_params(params);

        assert_eq!(optimizer.params.optimal_arousal, 0.7);
        assert_eq!(optimizer.params.optimal_zone_width, 0.3);
    }

    #[test]
    fn test_frequency_to_arousal_mapping() {
        let mut optimizer = WundtOptimizer::new();

        // Test different frequency ranges
        let low_arousal = optimizer.frequency_to_arousal(0.5);
        let optimal_arousal = optimizer.frequency_to_arousal(30.0); // Peak of the curve
        let high_arousal = optimizer.frequency_to_arousal(50.0);

        assert!(low_arousal < optimal_arousal);
        assert!(optimal_arousal > high_arousal);
        assert!(optimal_arousal > 0.5);
    }

    #[test]
    fn test_arousal_computation() {
        let mut optimizer = WundtOptimizer::new();
        let mut network = OscillatoryNetwork::with_size(10);
        let features = TopologicalFeatures {
            feature_vector: vec![0.5; 8],
            betti_numbers: crate::perceptual::topological_perceiver::BettiNumbers::default(),
            persistence_entropy: 0.3,
            max_persistence: crate::perceptual::topological_perceiver::PersistenceMeasures::default(
            ),
            timestamp: 1.0,
        };

        network.apply_input_pattern(InputPattern::Uniform(0.6));
        network.run_steps(50);

        let arousal = optimizer.compute_arousal(&network, &features);

        assert!(arousal >= 0.0 && arousal <= 1.0);
        assert!(arousal > 0.0); // Should have some arousal
    }

    #[test]
    fn test_motivation_computation() {
        let mut optimizer = WundtOptimizer::new();

        // Test optimal arousal
        optimizer.current_arousal = 0.6; // Exactly optimal
        let motivation = optimizer.compute_motivation();
        assert!(motivation > 0.8);

        // Test under-arousal
        optimizer.current_arousal = 0.2;
        let motivation = optimizer.compute_motivation();
        assert!(motivation < 0.8);

        // Test over-arousal
        optimizer.current_arousal = 0.9;
        let motivation = optimizer.compute_motivation();
        assert!(motivation < 0.8);
    }

    #[test]
    fn test_optimal_action_determination() {
        let mut optimizer = WundtOptimizer::new();

        // Test optimal zone
        optimizer.current_arousal = 0.6;
        optimizer.exploration_drive = 0.3;
        let action = optimizer.determine_optimal_action();
        assert_eq!(action, MotivationalAction::MaintainOptimal);

        // Test under-arousal
        optimizer.current_arousal = 0.3;
        let action = optimizer.determine_optimal_action();
        assert_eq!(action, MotivationalAction::IncreaseComplexity);

        // Test over-arousal
        optimizer.current_arousal = 0.8;
        let action = optimizer.determine_optimal_action();
        assert_eq!(action, MotivationalAction::DecreaseComplexity);
    }

    #[test]
    fn test_control_signal_generation() {
        let mut optimizer = WundtOptimizer::new();

        // Test increase complexity signals
        optimizer.current_arousal = 0.3; // Under-aroused
        optimizer.generate_control_signals();

        assert!(optimizer.control_signals.frequency_adjustment > 0.0);
        assert!(optimizer.control_signals.inhibition_adjustment < 0.0);
        assert!(optimizer.control_signals.noise_signal > 0.3);
    }

    #[test]
    fn test_arousal_history() {
        let mut optimizer = WundtOptimizer::new();

        // Add some arousal values
        for i in 0..5 {
            optimizer.update_arousal(0.5 + i as f64 * 0.1);
        }

        let history = optimizer.get_arousal_history();
        assert_eq!(history.len(), 5);
        assert!(history[4] > history[0]); // Should be increasing
    }

    #[test]
    fn test_optimizer_statistics() {
        let mut optimizer = WundtOptimizer::new();
        let stats = optimizer.get_statistics();

        assert_eq!(stats.optimal_arousal, 0.6);
        assert_eq!(stats.current_arousal, 0.5);
        assert_eq!(stats.motivation, 0.5);
        assert_eq!(stats.exploration_drive, 0.3);
        assert_eq!(stats.history_length, 0);
    }

    #[test]
    fn test_optimizer_reset() {
        let mut optimizer = WundtOptimizer::new();

        // Modify state
        optimizer.current_arousal = 0.8;
        optimizer.motivation = 0.9;
        optimizer.exploration_drive = 0.7;
        optimizer.arousal_history.push_back(0.6);

        // Reset
        optimizer.reset();

        // Verify reset
        assert_eq!(optimizer.current_arousal, 0.5);
        assert_eq!(optimizer.motivation, 0.5);
        assert_eq!(optimizer.exploration_drive, 0.3);
        assert!(optimizer.arousal_history.is_empty());
    }
}
