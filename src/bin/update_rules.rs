use splatrag::config::{HyperParameters, SplatMemoryConfig};
use splatrag::search::{SearchMode, Searcher};
use std::fs;
use std::path::Path;

fn main() -> anyhow::Result<()> {
    println!("üß† SplatRag: Auto-Rules Generator");
    println!("=================================");

    let config = SplatMemoryConfig::default();
    let searcher = Searcher::new(config, Path::new("./data"))?;
    let hyper_params = HyperParameters::default();

    let query = "What are the coding standards, architectural patterns, and project rules for this codebase?";
    println!("‚ùì Querying: '{}'", query);

    let results = searcher.search(query, SearchMode::Rainbow, None, &hyper_params)?;

    if results.is_empty() {
        println!("‚ùå No memories found to generate rules.");
        return Ok(());
    }

    println!("‚úÖ Found {} relevant memories.", results.len());

    let mut rules_content = String::from("# .cursorrules (Auto-Generated by SplatRag)\n\n");

    for (i, res) in results.iter().take(5).enumerate() {
        rules_content.push_str(&format!(
            "## Rule {}: Derived from Memory {}\n",
            i + 1,
            res.id
        ));
        let snippet = res
            .text
            .lines()
            .next()
            .unwrap_or("")
            .chars()
            .take(100)
            .collect::<String>();
        rules_content.push_str(&format!("> {}\n\n", snippet));
    }

    fs::write(".cursorrules", rules_content)?;
    println!("‚ú® Updated .cursorrules with latest brain context.");

    Ok(())
}
